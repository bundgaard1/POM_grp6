class Controller_22

instance variables

    public ctl_angle : real;       -- angle of arm in radians
    public ctl_angle_vel : real;
    public ctl_angle_acc : real;
    public ctl_prev_angle : real;
    public same_angle_counter : real;

    public ctl_angle_target : real;  -- taget angel of the arm in radians 
    public shut_down : bool;

    public ctl_mode : Mode;

    motor : Motor_22;
    angleSensor : Angle_sensor_22;

   
    Kp : real; -- Proportional factor 
    Kd : real; -- derivative factor 
   
    e_last : real;  -- error at last control

types 
    public Mode = <Initialisation> | <Normal> | <Emergency_stop> | <Shut_off>

values 

    M1 : real = -0.2;   -- Minimum limit for arm
    M2 : real = 1.77;   -- Maximum limit for arm
    N1 : real = 0;    -- minimum limit for target
    N2 : real = 1.57; -- maximum limit for target

    I : real = 0.1;     -- Inertia of robot arm should be calculated: I = m*r^2
    mass : real = 0.1;     -- Mass 
    r : real = 1;       -- Length

operations

    public Controller_22: Motor_22 * Angle_sensor_22 * RealPort * RealPort ==> Controller_22
    Controller_22(m, as, Kp_port, Kd_port) == (
        ctl_angle := 0;
        ctl_angle_vel := 0;
        ctl_angle_acc := 0;
        ctl_angle_target := ctl_angle;
        e_last := 0;
        shut_down := false;
        ctl_prev_angle := -1;
        same_angle_counter := 0;
        ctl_mode := <Initialisation>;

        angleSensor := as;
        motor := m;

        Kp := Kp_port.getValue();
        Kd := Kd_port.getValue();

    );

    public setTarget : (real) ==> ()
    setTarget(new_target) == duration(1E7)(

        if N1 < new_target and new_target < N2 then
            ctl_angle_target := new_target;
    );

    public monitorArmAngle : () ==> ()
    monitorArmAngle() == duration(1E7)(
        ctl_angle := angleSensor.getArmAngle();     
    );


    public controlTheMotor : () ==> ()
    controlTheMotor() == duration(1E7)(
        dcl e : real;
        dcl t_motor1 : real;
        dcl de : real;       
        dcl t_motor2 : real;

        -- PD controller

        e := ctl_angle_target - ctl_angle;  -- error from e(t_i) 
        
        -- Proportional
        t_motor1 := Kp * e;

        -- Derivative
        de := e - e_last;           -- change of error    
        t_motor2 := Kd * de;

        -- Set Tourqe on world
        motor.setTorque(t_motor1 + t_motor2);

        e_last := e;
    );

    public loop : () ==> ()
    loop() == cycles(2)(
        if ctl_mode = <Initialisation> then (
            monitorArmAngle();

            if not sys_OK() then (
                ctl_mode := <Emergency_stop>;
            ) else (
                ctl_mode := <Normal>;
            )
            
        ) else if (ctl_mode = <Normal>) then (
            if not sys_OK() then (
                ctl_mode := <Emergency_stop>;
            ) else if shut_down = true then (
                ctl_mode := <Shut_off>;
            ) else (
                monitorArmAngle();
                controlTheMotor();
            )
                        
        ) else if (ctl_mode = <Emergency_stop>) then (
            motor.setTorque(0);

        ) else if (ctl_mode = <Shut_off>) then (
            setKd(3);
            setKp(0.1);             
            setTarget(0)
        )
    );

    public sys_OK : () ==> (bool)
    sys_OK() == duration(0)(


        if ctl_angle = ctl_prev_angle then (
            same_angle_counter := same_angle_counter + 1;
        ) else (
            same_angle_counter := 0;
        );

        if ctl_angle < M1 or ctl_angle > M2 then (
            return false;
        );

        if same_angle_counter > 5 then (
            return false;
        );

        if motor.motor_failed then (
            return false;
        );

        return true;
    );


    public setKd : (real) ==> ()
    setKd(newKd) == duration(0)(
        Kd := newKd;
    );

    public setKp : (real) ==> ()
    setKp(newKp) == duration(0)(
        Kp := newKp;
    );


thread
    periodic(10E6,0,0,0)(loop);

end Controller_22